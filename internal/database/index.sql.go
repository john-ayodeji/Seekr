// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: index.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const countDocuments = `-- name: CountDocuments :one
SELECT COUNT(*), COALESCE(AVG(doc_len), 0)
FROM documents
`

type CountDocumentsRow struct {
	Count    int64
	Coalesce interface{}
}

func (q *Queries) CountDocuments(ctx context.Context) (CountDocumentsRow, error) {
	row := q.db.QueryRowContext(ctx, countDocuments)
	var i CountDocumentsRow
	err := row.Scan(&i.Count, &i.Coalesce)
	return i, err
}

const fetchPostingsForTerms = `-- name: FetchPostingsForTerms :many
SELECT d.id, d.url, d.title, d.doc_len, p.field, t.term, p.positions
FROM terms t
JOIN postings p ON p.term_id = t.id
JOIN documents d ON d.id = p.doc_id
WHERE t.term = ANY($1)
`

type FetchPostingsForTermsRow struct {
	ID        uuid.UUID
	Url       string
	Title     sql.NullString
	DocLen    int32
	Field     string
	Term      string
	Positions []int32
}

func (q *Queries) FetchPostingsForTerms(ctx context.Context, term string) ([]FetchPostingsForTermsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPostingsForTerms, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPostingsForTermsRow
	for rows.Next() {
		var i FetchPostingsForTermsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.DocLen,
			&i.Field,
			&i.Term,
			pq.Array(&i.Positions),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTermID = `-- name: GetTermID :one
SELECT id FROM terms WHERE term = $1
`

func (q *Queries) GetTermID(ctx context.Context, term string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getTermID, term)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertTerm = `-- name: InsertTerm :exec
INSERT INTO terms (id, term) VALUES ($1, $2)
ON CONFLICT (term) DO NOTHING
`

type InsertTermParams struct {
	ID   uuid.UUID
	Term string
}

func (q *Queries) InsertTerm(ctx context.Context, arg InsertTermParams) error {
	_, err := q.db.ExecContext(ctx, insertTerm, arg.ID, arg.Term)
	return err
}

const upsertDocument = `-- name: UpsertDocument :one
INSERT INTO documents (id, url, title, doc_len, last_crawled_at)
VALUES ($1, $2, $3, $4, now())
ON CONFLICT (url)
DO UPDATE SET title = EXCLUDED.title, doc_len = EXCLUDED.doc_len, last_crawled_at = EXCLUDED.last_crawled_at
RETURNING id
`

type UpsertDocumentParams struct {
	ID     uuid.UUID
	Url    string
	Title  sql.NullString
	DocLen int32
}

func (q *Queries) UpsertDocument(ctx context.Context, arg UpsertDocumentParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, upsertDocument,
		arg.ID,
		arg.Url,
		arg.Title,
		arg.DocLen,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const upsertPosting = `-- name: UpsertPosting :exec
INSERT INTO postings (term_id, doc_id, field, positions)
VALUES ($1, $2, $3, $4)
ON CONFLICT (term_id, doc_id, field)
DO UPDATE SET positions = postings.positions || EXCLUDED.positions
`

type UpsertPostingParams struct {
	TermID    uuid.UUID
	DocID     uuid.UUID
	Field     string
	Positions []int32
}

func (q *Queries) UpsertPosting(ctx context.Context, arg UpsertPostingParams) error {
	_, err := q.db.ExecContext(ctx, upsertPosting,
		arg.TermID,
		arg.DocID,
		arg.Field,
		pq.Array(arg.Positions),
	)
	return err
}
